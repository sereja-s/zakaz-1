<?php

namespace core\base\model;

use core\base\controller\Singleton;

/** 
 * Класс для обратимого шифрования с использованием расширения openssl
 * 
 * Методы: public function encrypt(); public function decrypt(); protected function cryptCombine(); 
 *         protected function cryptUnCombine()
 */
class Crypt
{
	use Singleton;

	// в свойстве сохраним метод шифрования
	private $cryptMethod = 'AES-128-CBC';

	// алгоритм хеширования
	private $hashAlgoritm = 'sha256';

	// длина хеша для алгоритма хеширования
	private $hashLength = 32;

	/** 
	 * Метод для шифрования данных
	 */
	public function encrypt($str)
	{
		// Получим псевдослучайную последовательность байт определённой длины (вектор шифрования) Это также необходимо 
		// для шифрования и дешифрования данных Генерировать надо на основании нашего метода шифрования (из свойства:
		// $cryptMethod) и определёной длины

		// Получим длину вектора шифрования
		$ivlen = openssl_cipher_iv_length($this->cryptMethod);

		// сгенерируем псевдослучайную последовательность (получим вектор шифрования)
		$iv = openssl_random_pseudo_bytes($ivlen);

		// необходимо зашифровать данные (4-ым параметром передадим константу библиотеки OPENSSL: OPENSSL_RAW_DATA- 
		// вернётся строка кодированная кодировкой: строка с двоичными данными ) Эта константа равна 1
		$cipherText = openssl_encrypt($str, $this->cryptMethod, CRYPT_KEY, OPENSSL_RAW_DATA, $iv);

		//exit;

		// для дешифровки необходимо создать хеш для шифрованной строки (4-ый параметр: true означает, что получим 
		// результат в качестве необработанных двоичных данных (если false- в 16-тиричной кодировке в нижнем регистре))
		$hmac = hash_hmac($this->hashAlgoritm, $cipherText, CRYPT_KEY, true);

		// вернём результат (данные) в кодировке: base64 (результат работы функции: cryptCombine())
		return $this->cryptCombine($cipherText, $iv, $hmac);

		// Для тестирования методов опишем следующие строки:
		// строка, которую необходимо зашифроватьи затем расшифровать
		//$cipherText_comb = '1122';

		// Строки должны иметь корректные значения чтобы их изымать

		// Длина вектор шифрования в алгоритме (в объявленном ранее в свойстве: private $cryptMethod = 'AES-128-CBC')
		// составляет 16 символов (важно: какой вектор получили на входе, такой должны изъять на выходе)
		//$iv_comb = 'abcdefghijklmnop';

		// хеш ожидатся: 32 символа (т.к. в начале мы объявили свойство: private $hashLength = 32;)
		//$hmac_comb = '00000000000000000000000000000000';

		//$res = $this->cryptCombine($cipherText_comb, $iv_comb, $hmac_comb);
		//$crypt_data = $this->cryptUnCombine($res, $ivlen);

		//exit;
	}

	/** 
	 * Метод для расшифровки данных
	 */
	public function decrypt($str)
	{
		// Получим длину вектора шифрования
		$ivlen = openssl_cipher_iv_length($this->cryptMethod);

		$crypt_data = $this->cryptUnCombine($str, $ivlen);

		// расшифровка данных (получаем оригинальный текст)
		$original_plaintext = openssl_decrypt($crypt_data['str'], $this->cryptMethod, CRYPT_KEY, OPENSSL_RAW_DATA, $crypt_data['iv']);

		// получим хеш финальной (расшифрованной) строки (аналогично тому как получали ранее для $hmac)
		$calcmac = hash_hmac($this->hashAlgoritm, $crypt_data['str'], CRYPT_KEY, true);

		// осуществим сравнение, которое не подвержено атаке по времени при помощи ф-ии: hash_equals() 
		// Эта функция сравнивает 2-е строки (их хеши) на идентичность (поданные на вход), используя одно и тоже время
		if (hash_equals($crypt_data['hmac'], $calcmac)) {

			return $original_plaintext;
		}

		return false;
	}

	/** 
	 * Метод собирающий шифрованную строку (Выпуск №72 модернизация системы шифрования)
	 */
	protected function cryptCombine($str, $iv, $hmac)
	{
		// переменная с изначально пустой строкой (в неё будем добавлять)
		$new_str = '';

		$str_len = strlen($str);

		// получим счётчик с которого начнём добавление (расчётное значение, приведённое к типу int)
		// матеметическая ф-я php: ceil(), приводит дробное значение поданное на вход к ближайшему целому числу или к 
		// ближайшему дробному (если указан дополнительный параметр)
		$counter = (int)ceil(strlen(CRYPT_KEY) / ($str_len + $this->hashLength));

		//exit;

		// объявим переменную, которая будет осуществлять изменение прогресса (через сколько символов будет происзодить чередование строк)
		$progress = 1;

		// если переменная: $counter больше или равно переменной: $str_len
		if ($counter >= $str_len) {

			// то присвоим переменной: $counter значние 1
			$counter = 1;
		}

		// пройдёмся в цикле по всей длине строки
		for ($i = 0; $i < $str_len; $i++) {

			if ($counter < $str_len) {

				// если соблюдается условие, 
				if ($counter === $i) {

					// то в переменную добавим результат работы ф-ии: substr(), в которой из строки: $iv, начиная с символа под номером: ($progress - 1) вернём подстроку длиной в 1-н символ
					$new_str .= substr($iv, $progress - 1, 1);

					$progress++;

					$counter += $progress;
				}
			} else {

				break;
			}

			// в переменную добавим результат работы ф-ии: substr(), т.е. вернём подстроку длиной: 1-н символ, начиная 
			// с $i-го символа из строки: в переменной: $str
			$new_str .= substr($str, $i, 1);
		}

		//exit;

		// допишем строку в переменной: $new_str (после выхода из цикла) оставшимися символами строки: $str, начиная с её крайнего $i-го символа
		$new_str .= substr($str, $i);

		// затем добавим остатки строки от вектора шифрования: $iv
		$new_str .= substr($iv, $progress - 1);

		//exit;

		// найдём середину полученной строки
		$new_str_half = (int)ceil(strlen($new_str) / 2);

		// соберём готовую строку, конкатенировав в её середину строку которая хранится в $hmac
		$new_str = substr($new_str, 0, $new_str_half) . $hmac . substr($new_str, $new_str_half);

		//exit;

		// вернём строку в кодировке: base64
		return base64_encode($new_str);
	}

	/** 
	 * Метод разбирающий шифрованную строку 
	 * (На вход: 1- строка и 2- длина вектора шифрования)
	 */
	protected function cryptUnCombine($str, $ivlen)
	{
		// объявим пустой массив в котором будут находиться строка и вектор шифрования
		$crypt_data = [];

		// декодируем (получим строку без base64)
		$str = base64_decode($str);

		// получим позицию с которой в итоговой строке вставлен хеш (всю итоговую строку делим на пополам (находим 
		// середину) и затем вычитаем половину от длины хеша (здесь- 32/2=16)) Затем результат приводим к целочисленному и 
		// округляем до ближайшего целого числа
		$hash_position = (int)ceil((strlen($str) / 2) - ($this->hashLength / 2));

		// вырежем подстроку (хеш) из строки: $str, начиная с: $hash_position, длиной указаной в текущем свойстве: $hashLength и сохраним в ячейке:
		$crypt_data['hmac'] = substr($str, $hash_position, $this->hashLength);

		//return $crypt_data;

		// заменим все вхождения строки поиска (хеша): $crypt_data['hmac'] на строку замены (пустую строку) в строке: $str
		$str = str_replace($crypt_data['hmac'], '', $str);

		//return $crypt_data;

		// получим счётчик: вычислим с какого места в полученной строке: $str начинать поиск вектора шифрования (т.е. 
		//первая позиция его вхождения)
		$counter = (int)ceil(strlen(CRYPT_KEY) / (strlen($str) - $ivlen + $this->hashLength));

		// получим первичную прогрессию (следующий символ от предыдущего будем искать через два символа, потом через три и т.д.)
		$progress = 2;

		// ячейка массива для хранения символов результирующей строки
		$crypt_data['str'] = '';

		// ячейка массива для хранения символов вектора шифрования
		$crypt_data['iv'] = '';

		// разбираем строку в цикле
		for ($i = 0; $i < strlen($str); $i++) {

			// если длина вектора шифрования с длиной результирующей строки меньше длины всей строки
			if ($ivlen + strlen($crypt_data['str']) < strlen($str)) {

				if ($i === $counter) {

					// значит это позиция символа вектора шифрования (вырежем и добавим этот символ в соответствующую ячейку массива вектора шифрования)
					$crypt_data['iv'] .= substr($str, $counter, 1);

					$progress++;

					$counter += $progress;

					// иначе
				} else {

					// это позиция символа результирующей строки (вырежем и добавим этот символ в соответствующую ячейку массива результирующей строки)
					$crypt_data['str'] .= substr($str, $i, 1);
				}

				// здесь мы вышли за пределы исходной строки (т.е. далее в результирующую строку нужно довырезать то, что осталось в конце вектора шифрования)
			} else {

				// получим длину последовательности символов в ячейке: $crypt_data['str']
				$crypt_data_len = strlen($crypt_data['str']);

				// в яейку получим (добавляем) символы результирующей строки: результат работы ф-ии: substr(), которая вырезает: (strlen($str) - $ivlen - $crypt_data_len), из строки: $str, начиная с символа: из $i
				$crypt_data['str'] .= substr($str, $i, strlen($str) - $ivlen - $crypt_data_len);

				// аналогично получим символы вектора шифрования и заполним остаток от вектора шифрования
				$crypt_data['iv'] .= substr($str, $i + (strlen($str) - $ivlen - $crypt_data_len));

				break;
			}
		}

		return $crypt_data;
	}
}
